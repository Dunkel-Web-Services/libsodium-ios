//
//  LibSodiumTesterTests.m
//  LibSodiumTesterTests
//
//  Created by Drew Crawford on 2/15/14.
//  Copyright (c) 2014 DrewCrawfordApps. All rights reserved.
//

#import <XCTest/XCTest.h>
#import <sodium.h>

@interface LibSodiumTesterTests : XCTestCase

@end

@implementation LibSodiumTesterTests

- (void)setUp
{
    [super setUp];
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

- (void)tearDown
{
    // Put teardown code here. This method is called after the invocation of each test method in the class.
    [super tearDown];
}

-(NSString*) stringForTest:(NSString*) test {
    NSBundle *testBundle = nil;
    for (NSBundle *bundle in [NSBundle allBundles]) {
        if ([bundle.bundlePath hasSuffix:@"xctest"]) {
            testBundle = bundle;
            break;
        }
    }
    NSString *path = [testBundle pathForResource:test ofType:@"exp"];
    NSString *compare2 = [[NSString alloc] initWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
    return compare2;
}

- (void)testBox
{
    
    
    NSMutableString *compare1 = [[NSMutableString alloc] init];
    unsigned char alicesk[32] = {
        0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d
        ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45
        ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a
        ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a
    } ;
    
    unsigned char bobpk[32] = {
        0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4
        ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37
        ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d
        ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f
    } ;
    
    unsigned char nonce[24] = {
        0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
        ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
        ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    } ;
    
    // API requires first 32 bytes to be 0
    unsigned char m[163] = {
        0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5
        ,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b
        ,0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4
        ,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc
        ,0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a
        ,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29
        ,0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4
        ,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31
        ,0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d
        ,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57
        ,0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a
        ,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde
        ,0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd
        ,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52
        ,0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40
        ,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64
        ,0x5e,0x07,0x05
    } ;
    
    unsigned char c[163];
        int i;
        crypto_box_curve25519xsalsa20poly1305(
                                              c,m,163,nonce,bobpk,alicesk
                                              );
        for (i = 16;i < 163;++i) {
            [compare1 appendFormat:@",0x%02x",(unsigned int) c[i]];
            if (i % 8 == 7) [compare1 appendFormat:@"\n"];
        }
    [compare1 appendFormat:@"\n"];
    XCTAssertEqualObjects(compare1, [self stringForTest:@"box"], @"String mismatch");

}

- (void) testBox2 {
#include <stdio.h>
    
    NSMutableString *compare1 = [[NSMutableString alloc ] init];
    unsigned char bobsk[32] = {
        0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b
        ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6
        ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd
        ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb
    } ;
    
    unsigned char alicepk[32] = {
        0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54
        ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a
        ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4
        ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a
    } ;
    
    unsigned char nonce[24] = {
        0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73
        ,0xcd,0x62,0xbd,0xa8,0x75,0xfc,0x73,0xd6
        ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37
    } ;
    
    // API requires first 16 bytes to be 0
    unsigned char c[163] = {
        0,   0,   0,   0,   0,   0,   0,   0
        ,   0,   0,   0,   0,   0,   0,   0,   0
        ,0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5
        ,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9
        ,0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73
        ,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce
        ,0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4
        ,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a
        ,0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b
        ,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72
        ,0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2
        ,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38
        ,0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a
        ,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae
        ,0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea
        ,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda
        ,0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde
        ,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3
        ,0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6
        ,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74
        ,0xe3,0x55,0xa5
    } ;
    
    unsigned char m[163];
    
        int i;
        if (crypto_box_curve25519xsalsa20poly1305_open(
                                                       m,c,163,nonce,alicepk,bobsk
                                                       ) == 0) {
            for (i = 32;i < 163;++i) {
                [compare1 appendFormat:@",0x%02x",(unsigned int) m[i]];
                if (i % 8 == 7) [compare1 appendFormat:@"\n"];
            }
            [compare1 appendFormat:@"\n"];
        }
    XCTAssertEqualObjects(compare1, [self stringForTest:@"box2"], @"String mismatch");

}

-(void) testBox7 {
    
    unsigned char alicesk[crypto_box_SECRETKEYBYTES] = {
        [0] = 0x77 ,
        [1] = 0xc3 ,
        [2] = 0x36 ,
        [3] = 0x07 ,
        [4] = 0x4b ,
        [5] = 0xe9 ,
        [6] = 0xdc ,
        [7] = 0xb6 ,
        [8] = 0x1d ,
        [9] = 0xb6 ,
        [10] = 0x64 ,
        [11] = 0x9f ,
        [12] = 0xfb ,
        [13] = 0xfe ,
        [14] = 0x4c ,
        [15] = 0x08 ,
        [16] = 0x8c ,
        [17] = 0xd9 ,
        [18] = 0xd6 ,
        [19] = 0xff ,
        [20] = 0x59 ,
        [21] = 0xec ,
        [22] = 0xd0 ,
        [23] = 0x92 ,
        [24] = 0xcb ,
        [25] = 0xf6 ,
        [26] = 0xab ,
        [27] = 0xaa ,
        [28] = 0xd5 ,
        [29] = 0x2f ,
        [30] = 0x2e ,
        [31] = 0x40 ,
    };
    unsigned char alicepk[crypto_box_PUBLICKEYBYTES] = {
        [0] = 0x01 ,
        [1] = 0x85 ,
        [2] = 0x56 ,
        [3] = 0x53 ,
        [4] = 0xc9 ,
        [5] = 0x82 ,
        [6] = 0xbd ,
        [7] = 0x14 ,
        [8] = 0xcf ,
        [9] = 0x8a ,
        [10] = 0x14 ,
        [11] = 0xa5 ,
        [12] = 0x16 ,
        [13] = 0x4a ,
        [14] = 0xa5 ,
        [15] = 0x1c ,
        [16] = 0x72 ,
        [17] = 0xdf ,
        [18] = 0x3d ,
        [19] = 0x45 ,
        [20] = 0x20 ,
        [21] = 0x25 ,
        [22] = 0x5b ,
        [23] = 0x76 ,
        [24] = 0x79 ,
        [25] = 0x63 ,
        [26] = 0x68 ,
        [27] = 0x85 ,
        [28] = 0x90 ,
        [29] = 0xe4 ,
        [30] = 0x3b ,
        [31] = 0x5a ,
    };
    
    unsigned char bobsk[crypto_box_SECRETKEYBYTES] = {
        [0] = 0x56 ,
        [1] = 0x5b ,
        [2] = 0x15 ,
        [3] = 0x0f ,
        [4] = 0x17 ,
        [5] = 0x4d ,
        [6] = 0x8d ,
        [7] = 0x8d ,
        [8] = 0x9d ,
        [9] = 0xf7 ,
        [10] = 0x37 ,
        [11] = 0x0f ,
        [12] = 0x70 ,
        [13] = 0xa9 ,
        [14] = 0x57 ,
        [15] = 0x4c ,
        [16] = 0xe5 ,
        [17] = 0x57 ,
        [18] = 0x9c ,
        [19] = 0xb0 ,
        [20] = 0x7b ,
        [21] = 0x32 ,
        [22] = 0x9e ,
        [23] = 0xea ,
        [24] = 0xe0 ,
        [25] = 0x0a ,
        [26] = 0x4e ,
        [27] = 0xd5 ,
        [28] = 0x57 ,
        [29] = 0x3b ,
        [30] = 0x95 ,
        [31] = 0x02 ,
    };
    unsigned char bobpk[crypto_box_PUBLICKEYBYTES] = {
        [0] = 0x90 ,
        [1] = 0x1e ,
        [2] = 0x34 ,
        [3] = 0x43 ,
        [4] = 0xc7 ,
        [5] = 0x4c ,
        [6] = 0xd6 ,
        [7] = 0x2d ,
        [8] = 0x9e ,
        [9] = 0x33 ,
        [10] = 0xbd ,
        [11] = 0x24 ,
        [12] = 0x09 ,
        [13] = 0x23 ,
        [14] = 0xc9 ,
        [15] = 0x07 ,
        [16] = 0x15 ,
        [17] = 0x6f ,
        [18] = 0xd8 ,
        [19] = 0x6c ,
        [20] = 0x1e ,
        [21] = 0xa9 ,
        [22] = 0xc5 ,
        [23] = 0x38 ,
        [24] = 0x3d ,
        [25] = 0xe0 ,
        [26] = 0x24 ,
        [27] = 0x7d ,
        [28] = 0xc5 ,
        [29] = 0x09 ,
        [30] = 0xea ,
        [31] = 0x26 ,
    };
    unsigned char n[crypto_box_NONCEBYTES] = {
        [0] = 0xad ,
        [1] = 0x1e ,
        [2] = 0x3a ,
        [3] = 0x1e ,
        [4] = 0x56 ,
        [5] = 0x69 ,
        [6] = 0xb5 ,
        [7] = 0xbc ,
        [8] = 0xb6 ,
        [9] = 0xcd ,
        [10] = 0x93 ,
        [11] = 0x7c ,
        [12] = 0x3a ,
        [13] = 0x4c ,
        [14] = 0x5f ,
        [15] = 0x39 ,
        [16] = 0x89 ,
        [17] = 0x30 ,
        [18] = 0x1f ,
        [19] = 0xbd ,
        [20] = 0x4b ,
        [21] = 0x50 ,
        [22] = 0x3b ,
        [23] = 0x13 ,
    };
    unsigned char m[10000] = {0}; //see https://github.com/jedisct1/libsodium/issues/117
    unsigned char c[10000];
    unsigned char m2[10000];

        size_t mlen;
        size_t i;
        
        for (mlen = 0;mlen < 1000 && mlen + crypto_box_ZEROBYTES < sizeof m;++mlen) {
            //crypto_box_keypair(alicepk,alicesk);
            //crypto_box_keypair(bobpk,bobsk);
            //randombytes(n,crypto_box_NONCEBYTES);
            randombytes(m + crypto_box_ZEROBYTES,mlen);
            crypto_box(c,m,mlen + crypto_box_ZEROBYTES,n,bobpk,alicesk);
            if (crypto_box_open(m2,c,mlen + crypto_box_ZEROBYTES,n,alicepk,bobsk) == 0) {
                for (i = 0;i < mlen + crypto_box_ZEROBYTES;++i)
                    if (m2[i] != m[i]) {
                        XCTFail(@"bad decryption\n");
                        break;
                    }
            } else {
                XCTFail(@"Cannot decrypt");
            }
        }


}

@end
